<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="icon" type="image/x-icon" href="icons/favicon.ico">
    <title>LLM Chess Leaderboard</title>
    <style>
        @font-face {
            font-family: 'Web IBM VGA 8x16';
            font-style: normal;
            font-weight: 400;
            src: url(web_ibm_vga_8x16.woff) format('woff');
        }

        @font-face {
            font-family: 'Chess';
            font-style: normal;
            font-weight: 400;
            /* src: url(segoe-w95-chess.woff) format('woff'); */
            src: url(DejavuSansMono.ttf) format('truetype');
        }

        body {
            background-color: #0000AA;
            color: #FFFFFF;
            font-family: "Web IBM VGA 8x16";
            text-align: center;
            margin: 0;
            font-size: 20px;
            overflow-y: scroll;
        }

        code {
            font-size: 20px;
            font-family: "Web IBM VGA 8x16";
        }

        div.center {
            width: 740px;
            margin: auto;
            padding-bottom: 30px;
            padding-left: 20px;
            padding-right: 20px;
        }

        a {
            color: greenyellow;
            text-decoration: none; 
        }

        .gh {
            color: yellowgreen;
        }

        .gh img {
            vertical-align: middle;
            width: 20px;
            height: 20px;
            margin-right: 5px;
            filter: invert(100%);
        }

        h1 {
            margin-bottom: 20px;
        }

        p.intro {
            display: block;
            margin:auto;
            text-align: justify;
        }

        .button-container {
            display: flex;
            justify-content: center;
            margin-top: 30px;
            margin-bottom: 40px;
        }

        button {
            width: 160px;
            margin: 0 5px;
            padding: 5px;
            background-color: #C0C0C0;
            color: #000000;
            border: 1px solid #808080;
            font-family: "Web IBM VGA 8x16";
            font-size: 20px;
            position: relative;
            cursor: pointer;
        }

        button::after {
            content: '';
            position: absolute;
            top: 8px;
            left: 8px;
            width: 100%;
            height: 100%;
            background-color: #000000;
            z-index: -1;
        }

        button.selected {
            background-color: green;
            color: #FFFFFF;
            top: 1px;
            left: 1px;
        }

        button:hover {
            background-color: #808080;
            color: #FFFFFF;
            top: 2px;
            left: 2px;
        }

        /* .pane{
            padding-top: 20px;
        } */

        pre.title {
            font-size: 16px;
            scale: 1.0;
            padding-top: 50px;
            color: greenyellow;
        }

        pre.snippet {
            font-family: "Web IBM VGA 8x16";
            text-align: left;
            color: greenyellow;
            overflow: auto;
        }

        pre.title-narrow {
            display: none;
        }

        .game {
            padding-bottom: 50px;
        }

        pre.board {
            font-family: 'Chess';
            font-size: 32px;
            width: 295px;
            height: 298px;
            background-color: black;
            text-align: justify;
            opacity: 0.85;
            line-height: 37px;
            margin: 0;
            padding-left: 5px;
            padding-top: 2px;
        }

        div.board::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        div.board {
            width: 300px;
            height: 300px;
            padding: 5px;
            margin-top: 20px;
            margin-bottom: 20px;
            margin-left: auto;
            margin-right: auto;
            position: relative;
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, .9);
            margin: 5px;
            width: 300px;
            height: 300px;
            text-align: center;
            display: none;
        }

        @keyframes blink {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0;
            }
        }
        
        .game-over p {
            color: red;
            font-size: 40px;
            font-weight: bold;
            animation: blink 1s infinite;
        }

        .game-over span {
            text-align: left;
            display: inline-flex;
        }

        p, pre {
            color: lightgray;
        }

        .table-container {
            overflow-x: auto;
            padding: 0;
        }

        table {
            margin-bottom: 40px;
            min-width: 720px;
            width: 100%;
            border-collapse: collapse;
        }
        
        td, th {
            padding: 10px;
            font-weight: lighter;
            text-align: left;
        }

        th {
            cursor: pointer;
        }

        th:hover {
            cursor: pointer;
            color: yellowgreen;
        }

        tr:hover td{
            color: yellowgreen;
        }

        td {
            border-top: 1px solid;
            cursor: default;
            color: lightgray;
        }

        th:nth-child(even), td:nth-child(even) {
            background-color: black;
        }

        table tbody tr:nth-last-child(-n+3) td {
            color: greenyellow !important;
        }

        .descriptions {
            text-align: left;
            padding-top: 0;
        }
        
        .descriptions strong {
            font-weight: normal;
            color: white;
        }

        #popup {
            display: none;
            position: absolute;
            background-color: #333;
            color: #fff;
            z-index: 1000;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            text-align: left;
        }
        
        #popup p {
            margin: 0;
        }

        /* Responsive styles for mobile devices */
        @media (max-width: 768px) {
            body {
                font-size: 18px;
            }

            div.center {
                width: 90%;
            }

            h1 {
                font-size: 24px;
            }

            p.intro {
                width: 100%;
            }

            div.board {
                scale: 0.9;
            }

            button {
                width: 140px;
                font-size: 18px;
            }

            pre.title {
                display: none;
            }

            pre.title-narrow {
                display: block;
                font-size: 10px;
                padding-top: 20px;
                padding-bottom: 20px;
                color: white;
                max-width: 325px;
                overflow-x: hidden;
                margin: auto;
                line-height: 1.3;
                color: greenyellow;
            }

            td, th {
                padding: 8px;
            }

            .button-container {
                flex-direction: column;
                align-items: center;
            }

            .button-container button {
                margin: 5px 0;
            }
        }
    </style>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4SS6VHS4QF"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-4SS6VHS4QF');
    </script>
    <script>
            data = `
Player,total_games,player_wins,opponent_wins,draws,player_wins_percent,player_draws_percent,total_moves,player_wrong_actions,player_wrong_moves,player_avg_material,opponent_avg_material,material_diff_player_llm_minus_opponent,material_diff_player_minus_opponent_per_1000moves,wrong_actions_per_1000moves,wrong_moves_per_1000moves,average_moves,completion_tokens_black_per_move
o1-preview-2024-09-12,30,14,3,13,46.666666666666664,43.333333333333336,3744,4,10,11.512286324786325,1.5224358974358974,9.989850427350428,2.668229280809409,1.0683760683760686,2.6709401709401708,124.8,2660.071848290598
o1-mini-2024-09-12,30,9,6,15,30.0,50.0,4282,2,8,13.582438113031294,2.8169079869219993,10.765530126109295,2.5141359472464493,0.4670714619336758,1.8682858477347033,142.73333333333332,1221.1361513311538
anthropic.claude-v3-5-sonnet-v1,60,4,8,48,6.666666666666667,80.0,11003,0,3,12.030628010542578,16.514768699445607,-4.484140688903029,-0.4075380068075097,0.0,0.27265291284195226,183.38333333333333,80.42406616377352
anthropic.claude-v3-5-sonnet-v2,60,2,5,53,3.3333333333333335,88.33333333333333,11292,0,8,9.746103436060928,13.091126461211477,-3.3450230251505495,-0.2962294567083377,0.0,0.7084661707403471,188.2,90.8544987601842
anthropic.claude-v3-haiku,40,0,40,0,0.0,0.0,1334,7,4,34.80209895052474,35.54422788605697,-0.7421289355322358,-0.556318542377988,5.247376311844079,2.9985007496251876,33.35,210.64017991004496
anthropic.claude-v3-opus,30,0,5,25,0.0,83.33333333333334,4968,1,7,12.051529790660226,18.840378421900162,-6.7888486312399365,-1.3665154249677811,0.20128824476650564,1.4090177133655393,165.6,72.8623188405797
gemini-2.0-flash-exp,30,0,28,2,0.0,6.666666666666667,2576,0,81,17.729813664596275,17.31832298136646,0.41149068322981464,0.15974017206126345,0.0,31.444099378881987,85.86666666666666,168.15023291925465
gemini-2.0-flash-thinking-exp-1219,30,0,30,0,0.0,0.0,70,89,1,39.0,39.0,0.0,0.0,1271.4285714285713,14.285714285714286,2.3333333333333335,724.5428571428571
gemini-2.0-flash-thinking-exp-01-21,33,0,31,2,0.0,6.0606060606060606,1341,7,1,29.72035794183445,30.26771066368382,-0.5473527218493679,-0.40816757781459206,5.219985085756898,0.7457121551081282,40.63636363636363,17.76957494407159
gemini-1.5-flash-001,30,0,20,10,0.0,33.33333333333333,2524,18,36,16.69136291600634,31.438985736925517,-14.747622820919176,-5.842956743628833,7.131537242472267,14.263074484944534,84.13333333333334,19.914817749603802
gemini-1.5-pro-preview-0409,30,0,27,3,0.0,10.0,2558,14,61,22.0852228303362,28.233776387802973,-6.148553557466773,-2.403656590096471,5.473025801407349,23.846755277560593,85.26666666666667,13.407740422204848
gemma-2-27b-it@q6_k_l,30,0,22,8,0.0,26.666666666666668,3268,8,52,18.94706242350061,20.79406364749082,-1.8470012239902083,-0.5651778531181788,2.4479804161566703,15.911872705018359,108.93333333333334,55.04436964504284
gemma-2-9b-it@q8_0,30,0,26,4,0.0,13.333333333333334,2075,45,31,23.387469879518072,26.799036144578313,-3.411566265060241,-1.6441283205109594,21.686746987951807,14.93975903614458,69.16666666666667,58.12433734939759
gpt-4-turbo-2024-04-09,30,0,2,28,0.0,93.33333333333333,5786,0,0,14.936571033529209,20.29001036985828,-5.353439336329071,-0.9252401203472298,0.0,0.0,192.86666666666667,6.032837884548911
gpt-4o-2024-05-13,60,0,12,48,0.0,80.0,11057,1,16,12.585601881161255,16.568056434837658,-3.982454553676403,-0.3601749618953064,0.09044044496698922,1.4470471194718275,184.28333333333333,31.334720086822827
gpt-4o-2024-08-06,60,1,9,50,1.6666666666666667,83.33333333333334,11214,0,1,14.141787051899412,18.534242910647404,-4.392455858747992,-0.39169394139004743,0.0,0.08917424647761726,186.9,7.70322810772249
gpt-4o-2024-11-20,71,3,6,62,4.225352112676056,87.32394366197182,13470,1,1,11.130734966592428,19.365330363771342,-8.234595397178914,-0.6113285372812853,0.07423904974016333,0.07423904974016333,189.71830985915494,50.575278396436524
gpt-4o-mini-2024-07-18,30,0,12,18,0.0,60.0,4481,13,24,17.146172729301494,21.37982593171167,-4.233653202410178,-0.9448009824615439,2.9011381388083017,5.355947333184558,149.36666666666667,108.21624637357732
deepseek-reasoner-r1,28,5,17,6,17.857142857142858,21.428571428571427,2553,7,42,12.731688209949079,3.157070113591853,9.574618096357225,3.750340029908823,2.7418723070896984,16.45123384253819,91.17857142857143,4588.827262044653
deepseek-chat,70,0,68,2,0.0,2.857142857142857,4043,10,180,25.59930744496661,24.216176106851346,1.3831313381152626,0.3421052035902208,2.473410833539451,44.52139500371011,57.75714285714286,246.92604501607718
deepseek-r1-distill-qwen-14b@q8_0,30,0,30,0,0.0,0.0,78,82,8,39.0,39.0,0.0,0.0,1051.2820512820513,102.56410256410255,2.6,3073.0641025641025
deepseek-r1-distill-qwen-32b@q4_k_m,30,0,30,0,0.0,0.0,110,73,7,39.0,38.90909090909091,0.09090909090909349,0.826446280991759,663.6363636363637,63.63636363636363,3.6666666666666665,2173.827272727273
llama-3-70b-instruct-awq,30,0,15,15,0.0,50.0,4449,2,41,17.991458754776353,25.624185210159588,-7.632726455383235,-1.7156049573799135,0.4495392222971454,9.215554057091481,148.3,41.60890087660148
qwq-32b-preview@q4_k_m,30,0,30,0,0.0,0.0,239,44,17,38.8326359832636,38.90794979079498,-0.07531380753137995,-0.3151205336041002,184.10041841004184,71.12970711297072,7.966666666666667,2908.0
qwen2.5-14b-instruct@q8_0,30,0,30,0,0.0,0.0,398,29,59,38.19095477386934,37.79899497487437,0.391959798994975,0.9848236155652639,72.8643216080402,148.24120603015075,13.266666666666667,150.63065326633165
sky-t1-32b-preview@q4_0,30,0,30,0,0.0,0.0,415,9,59,38.40240963855422,38.62409638554217,-0.22168674698794888,-0.5341849325010816,21.686746987951807,142.1686746987952,13.833333333333334,1216.1590361445783
llama3.1-8b,90,0,87,3,0.0,3.3333333333333335,2436,44,188,34.933497536945815,36.902709359605915,-1.9692118226600996,-0.8083792375451969,18.062397372742197,77.17569786535304,27.066666666666666,162.1013957307061
llama-3.3-70b,42,0,38,4,0.0,9.523809523809524,2886,2,100,19.927581427581426,26.3007623007623,-6.373180873180875,-2.2083093808665537,0.6930006930006929,34.65003465003465,68.71428571428571,102.98163548163548
llama3-8b-8192,60,0,60,0,0.0,0.0,902,104,66,37.23946784922395,38.50110864745011,-1.2616407982261606,-1.3987148539092689,115.29933481152993,73.17073170731706,15.033333333333333,57.019955654102
phi-4@q8,30,0,30,0,0.0,0.0,232,44,46,39.0,39.0,0.0,0.0,189.65517241379308,198.27586206896552,7.733333333333333,333.5431034482759
gpt-35-turbo-0125,30,0,30,0,0.0,0.0,86,90,0,39.0,39.0,0.0,0.0,1046.5116279069769,0.0,2.8666666666666667,82.02325581395348
gpt-35-turbo-0301,30,0,30,0,0.0,0.0,68,90,0,39.0,39.0,0.0,0.0,1323.5294117647059,0.0,2.2666666666666666,67.05882352941177
gpt-35-turbo-0613,30,0,30,0,0.0,0.0,124,90,0,39.0,38.903225806451616,0.09677419354838435,0.7804370447450351,725.8064516129032,0.0,4.133333333333334,93.62903225806451
gpt-35-turbo-1106,30,0,30,0,0.0,0.0,108,88,2,39.0,39.0,0.0,0.0,814.8148148148148,18.518518518518515,3.6,48.324074074074076
granite-3.1-8b-instruct@q8_0,30,0,30,0,0.0,0.0,126,47,12,38.93650793650794,39.0,-0.06349206349206327,-0.5039052658100259,373.015873015873,95.23809523809524,4.2,469.12698412698415
internlm3-8b-instruct@q8_0,30,0,30,0,0.0,0.0,108,15,39,39.0,39.0,0.0,0.0,138.88888888888889,361.1111111111111,3.6,1543.898148148148
llama-2-7b-chat@q8_0,30,0,30,0,0.0,0.0,64,88,2,39.0,39.0,0.0,0.0,1375.0,31.25,2.1333333333333333,116.3125
mistral-small-instruct-2409,30,0,30,0,0.0,0.0,272,58,32,38.779411764705884,38.779411764705884,0.0,0.0,213.23529411764707,117.6470588235294,9.066666666666666,88.24264705882354
ministral-8b-instruct-2410@q8_0,30,0,30,0,0.0,0.0,282,56,34,38.59574468085106,38.38297872340426,0.2127659574468055,0.7544892108042747,198.58156028368796,120.56737588652481,9.4,72.11347517730496
mistral-nemo-12b-instruct-2407@q8_0,30,0,30,0,0.0,0.0,202,79,11,38.51485148514851,38.45544554455446,0.05940594059405413,0.2940888148220501,391.0891089108911,54.45544554455446,6.733333333333333,47.698019801980195
mixtral-8x7b-32768,20,0,20,0,0.0,0.0,40,60,0,39.0,39.0,0.0,0.0,1500.0,0.0,2.0,16.5
Stockfish chess engine (as Black),1000,1000,0,0,100.000,0.000,32368,0,0,38.21,21.01,17.21,0.53164,0.00,0.00,32.37,-
Random Player (as White),1000,105,0,895,10.5,89.5,190073,0,0,10.56,11.08,-0.52,-0.00274,0.00,0.00,190.07,-
Random Player (as Black),1000,0,105,895,0.000,89.5,190073,0,0,11.08,10.56,0.52,0.00274,0.00,0.00,190.07,-
            `

        let currentSortOrder = {}; // To track the current sort order for each column
        const defaultSortColumnIndex = 1; // Sort by "Draws %" by default
        const SPECIAL_ROWS = {
            STOCKFISH: "Stockfish chess engine (as Black)",
            RANDOM_WHITE: "Random Player (as White)",
            RANDOM_BLACK: "Random Player (as Black)"
        };

        function showPane(paneId) {
            document.getElementById('leaderboard').style.display = paneId === 'leaderboard' ? 'block' : 'none';
            document.getElementById('how-it-works').style.display = paneId === 'how-it-works' ? 'block' : 'none';
            document.getElementById('considerations').style.display = paneId === 'considerations' ? 'block' : 'none';
            document.querySelectorAll('.button-container button').forEach(button => {
                button.classList.remove('selected');
            });
            document.querySelector(`.button-container button[onclick="showPane('${paneId}')"]`).classList.add('selected');

            // Simulate a page view event in Google Analytics
            gtag('event', 'page_view', {
                'page_title': document.title + ' - ' + paneId,
                'page_path': '/' + paneId
            });
        }

        const csvIndices = {
                player: 0,
                total_games: 1,
                player_wins: 2, // Assuming the wins column is at index 2
                losses: 3,      // Assuming the losses column is at index 3
                draws: 4,       // Assuming the draws column is at index 4
                player_wins_percent: 5,
                player_draws_percent: 6,
                wrong_actions_per_1000moves: 14,
                wrong_moves_per_1000moves: 15,
                completion_tokens_black_per_move: 17,
                average_moves: 16,
                material_diff: 12,
                losses: 3 // Assuming the losses column is at index 3
            };

        function fillTableWithCSV() {
            const lines = data.trim().split('\n');
            const header = lines[0].split(',');
            const rows = lines.slice(1).map(row => row.split(','));

            // Separate the rows that should always be at the bottom
            const bottomRows = [];
            const otherRows = rows.filter(columns => {
                const player = columns[csvIndices.player];
                if (player === SPECIAL_ROWS.STOCKFISH ||
                    player === SPECIAL_ROWS.RANDOM_WHITE ||
                    player === SPECIAL_ROWS.RANDOM_BLACK) {
                    bottomRows.push(columns);
                    return false;
                }
                return true;
            });

            // Sort the remaining rows by "Wins", "Draws", and then "Mistakes" in descending order
            otherRows.sort((a, b) => {
                const winsA = parseFloat(a[csvIndices.player_wins_percent]);
                const winsB = parseFloat(b[csvIndices.player_wins_percent]);
                const drawsA = parseFloat(a[csvIndices.player_draws_percent]);
                const drawsB = parseFloat(b[csvIndices.player_draws_percent]);
                const mistakesA = parseFloat(a[csvIndices.wrong_actions_per_1000moves]) + parseFloat(a[csvIndices.wrong_moves_per_1000moves]);
                const mistakesB = parseFloat(b[csvIndices.wrong_actions_per_1000moves]) + parseFloat(b[csvIndices.wrong_moves_per_1000moves]);

                // Hierarchical sorting: Wins DESC, Draws DESC, Mistakes ASC
                return winsB - winsA || drawsB - drawsA || mistakesA - mistakesB;
            });

            const tbody = document.querySelector('#leaderboard tbody');
            [...otherRows, ...bottomRows].forEach(columns => {
                const player = columns[csvIndices.player];
                const player_wins_percent = parseFloat(columns[csvIndices.player_wins_percent]);
                const player_draws_percent = parseFloat(columns[csvIndices.player_draws_percent]);
                const wrong_actions_per_1000moves = parseFloat(columns[csvIndices.wrong_actions_per_1000moves]);
                const wrong_moves_per_1000moves = parseFloat(columns[csvIndices.wrong_moves_per_1000moves]);
                const mistakes = wrong_actions_per_1000moves + wrong_moves_per_1000moves;
                const tokens = parseFloat(columns[csvIndices.completion_tokens_black_per_move]);

                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${player}</td> <!-- Player first -->
                    <td>${player_wins_percent.toFixed(2)}%</td>
                    <td>${player_draws_percent.toFixed(2)}%</td>
                    <td>${mistakes.toFixed(2)}</td>
                    <td>${tokens.toFixed(2)}</td>
                `;
                tbody.appendChild(tr);

                // Add event listeners for hover and tap
                tr.addEventListener('mouseenter', () => showPopup(tr, columns));
                tr.addEventListener('mouseleave', hidePopup);
                tr.addEventListener('click', () => showPopup(tr, columns));
            });

            // Add a non-breaking space to all headers
            document.querySelectorAll('#leaderboard th').forEach((headerCell) => {
                const baseText = headerCell.textContent.trim();
                headerCell.innerHTML = `${baseText}&nbsp;&nbsp;`;
            });
            const materialAdvantageHeader = document.querySelectorAll('#leaderboard th')[1];
            const defaultSortColumnIndex = 1; // Assuming this is defined above
            const defaultSortHeader = document.querySelectorAll('#leaderboard th')[defaultSortColumnIndex];
            defaultSortHeader.innerHTML = `${defaultSortHeader.textContent.trim()}&nbsp;▼`;
            document.querySelectorAll('#leaderboard th').forEach((headerCell, index) => {
                headerCell.addEventListener('click', () => {
                    sortTable(index);
                });
            });
        }

        function sortTable(columnIndex) {
            const table = document.querySelector('#leaderboard tbody');
            const rows = Array.from(table.rows);
            const isNumericColumn = columnIndex !== 0; // Assuming first column is not numeric

            // Determine the current sort order for the column
            const currentOrder = currentSortOrder[columnIndex] || 'asc';
            const newOrder = currentOrder === 'asc' ? 'desc' : 'asc';
            currentSortOrder[columnIndex] = newOrder;

            // Separate the rows that should always be at the bottom
            const bottomRows = [];
            const otherRows = rows.filter(row => {
                const player = row.cells[0].textContent;
                if (player === SPECIAL_ROWS.STOCKFISH ||
                    player === SPECIAL_ROWS.RANDOM_WHITE ||
                    player === SPECIAL_ROWS.RANDOM_BLACK) {
                    bottomRows.push(row);
                    return false;
                }
                return true;
            });

            otherRows.sort((a, b) => {
                const aText = a.cells[columnIndex].textContent;
                const bText = b.cells[columnIndex].textContent;

                const comparison = isNumericColumn
                    ? parseFloat(aText) - parseFloat(bText)
                    : aText.localeCompare(bText);

                return newOrder === 'asc' ? comparison : -comparison;
            });

            // Append sorted rows and then the bottom rows
            [...otherRows, ...bottomRows].forEach(row => table.appendChild(row));

            // Clear all sort indicators
            document.querySelectorAll('#leaderboard th').forEach((headerCell) => {
                const baseText = headerCell.textContent.replace(/[▲▼]/g, '').trim();
                headerCell.innerHTML = `${baseText}&nbsp;&nbsp;`;
            });

            // Update header text with sorting indicator for the sorted column
            const sortedHeaderCell = document.querySelectorAll('#leaderboard th')[columnIndex];
            const baseText = sortedHeaderCell.textContent.replace(/[▲▼]/g, '').trim();
            const indicator = currentSortOrder[columnIndex] === 'asc' ? '▲' : '▼';
            sortedHeaderCell.innerHTML = `${baseText}${indicator ? '&nbsp;' + indicator : '&nbsp;&nbsp;'}`;
        }
        document.addEventListener('DOMContentLoaded', () => {
            fillTableWithCSV();
            fetchAndAnimateBoard();
            // Set initial sort order for the default column
            currentSortOrder[defaultSortColumnIndex] = 'desc'; // Assuming "Draws %" is the second column
        });

        function fetchAndAnimateBoard() {
            fetch('moves.txt')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.text();
                })
                .then(data => {
                    const boardStates = data.trim().split('-\n');
                    let currentIndex = 0;

                    let interval = 1000; // Initial interval in milliseconds
                    let resetGameInterval = 7000;

                    function animateBoard() {
                        document.querySelector('pre.board').textContent = boardStates[currentIndex].trim();
                        document.querySelector('div.game-over').style.display = 'none';
                        currentIndex = (currentIndex + 1) % boardStates.length;

                        if (currentIndex === 0) {
                            document.querySelector('div.game-over').style.display = 'block';
                            currentIndex = 0;
                            setTimeout(animateBoard, resetGameInterval);
                        } else {
                            // Decrease the interval progressively
                            interval = Math.max(50, interval - 25); // Decrease by 25ms, but not less than 50ms
                            setTimeout(animateBoard, interval);
                        }
                    }

                    animateBoard(); // Start the animation
                })
                .catch(error => {
                    console.error('Error fetching moves.txt:', error);
                });
        }

        function showPopup(row, columns) {
            const popup = document.getElementById('popup');
            const totalGames = columns[csvIndices.total_games];
            const wins = columns[csvIndices.player_wins]; // Retrieve wins
            const losses = columns[csvIndices.losses];    // Retrieve losses
            const draws = columns[csvIndices.draws];      // Retrieve draws
            const averageMoves = columns[csvIndices.average_moves]; // Retrieve average moves
            const materialDiff = columns[csvIndices.material_diff]; // Retrieve material difference

            document.getElementById('total-games').textContent = `Games: ${parseInt(totalGames)}`;
            document.getElementById('wins').textContent = `Wins: ${parseInt(wins)}`; // Add wins to popup
            document.getElementById('losses').textContent = `Losses: ${parseInt(losses)}`; // Add losses to popup
            document.getElementById('draws').textContent = `Draws: ${parseInt(draws)}`; // Add draws to popup
            document.getElementById('average-moves').textContent = `Average Moves: ${parseFloat(averageMoves).toFixed(2)}`; // Add average moves to popup
            document.getElementById('material-diff').textContent = `Material Diff: ${parseFloat(materialDiff).toFixed(2)}`; // Add material difference to popup

            const rect = row.getBoundingClientRect();
            if (window.innerWidth < 1200) {
                popup.style.top = `${rect.bottom + window.scrollY}px`;                
                popup.style.right = `${rect.left + window.scrollX}px`;
                popup.style.left = '';
            }
            else {
                popup.style.top = `${rect.top + window.scrollY}px`;
                popup.style.left = `${rect.right + window.scrollX}px`;
                popup.style.right = '';
            }
            popup.style.display = 'block';
        }

        function hidePopup() {
            const popup = document.getElementById('popup');
            popup.style.display = 'none';
        }
    </script>
</head>
<body>
    <div class="center">
        <pre class="title">
 __       __                    ____     __                               
/\ \     /\ \       /'\_/`\    /\  _``. /\ \                              
\ \ \    \ \ \     /\      \   \ \ \/\_\\ \ \___      __    ____    ____  
 \ \ \  __\ \ \  __\ \ \__\ \   \ \ \/_/_\ \  _ `\  /'__`\ /',__\  /',__\ 
  \ \ \L\ \\ \ \L\ \\ \ \_/\ \   \ \ \L\ \\ \ \ \ \/\  __//\__, `\/\__, `\
   \ \____/ \ \____/ \ \_\\ \_\   \ \____/ \ \_\ \_\ \____\/\____/\/\____/
    \/___/   \/___/   \/_/ \/_/    \/___/   \/_/\/_/\/____/\/___/  \/___/ 

        </pre>
        <pre class="title-narrow">
         __         __         __    __                        
        /\ \       /\ \       /\ "-./  \                       
        \ \ \____  \ \ \____  \ \ \-./\ \                      
         \ \_____\  \ \_____\  \ \_\ \ \_\                     
          \/_____/   \/_____/   \/_/  \/_/                                                                                
 ______     __  __     ______     ______     ______    
/\  ___\   /\ \_\ \   /\  ___\   /\  ___\   /\  ___\   
\ \ \____  \ \  __ \  \ \  __\   \ \___  \  \ \___  \  
 \ \_____\  \ \_\ \_\  \ \_____\  \/\_____\  \/\_____\ 
  \/_____/   \/_/\/_/   \/_____/   \/_____/   \/_____/ 
        </pre>
        <div class="game">
            <span style="color: yellow;">Random Player (White)</span>
            <div class="board">
<pre class="board">
♜ ♞ ♝ ♛ ♚ ♝ ♞ ♜
♟ ♟ ♟ ♟ ♟ ♟ ♟ ♟
· · · · · · · ·
· · · · · · · ·
· · · · · · · ·
· · · · · · · ·
♙ ♙ ♙ ♙ ♙ ♙ ♙ ♙
♖ ♘ ♗ ♕ ♔ ♗ ♘ ♖</pre>
                <div class="game-over">
                    <p>GAME OVER</p>
                    <span>
                        - Outcome: Draw<br>
                        - Max moves reached: 200<br>
                        - Material White: 16<br>
                        - Material Black: 18
                    </span>
                </div>
            </div>
            <span style="color: yellow;">GPT-4o Mini (Black)</span>
        </div>
        <p class="intro">
            Can a Large Language Model play chess? You can prompt it to make
            a move based on the board state, hint it with a list of legal moves (and ask to pick one). You will find that 
            an LLM can move pieces (but not all of them, some struggle with instruction following), even provide sound comments on why it made a certain move
            and what tactic or strategy it followed.
            <br/><br/>
            But can LLMs actually make any meaningful moves and win in a chess game? Why don't
            we put them up against a random player (i.e., a bot that randomly picks any move from a list of 
            legal moves for the current position). After all, the models are called Foundational Models for
            a reason; they have the knowledge of the entire Internet, can (supposedly) reason, and pass
            numerous math evaluations and PhD-level exams. What could be easier for an LLM than to score a victory over
            a chaos monkey?
            <br/><br/>
            Let's find out ツ
        </p>
        <div class="button-container">
            <button class="selected" onclick="showPane('leaderboard')">Leaderboard</button>
            <button onclick="showPane('how-it-works')">How it works</button>
            <button onclick="showPane('considerations')">Notes</button>
        </div>
        <div id="leaderboard" class="pane">
            <div class="table-container">
                <table border="0">
                    <thead>
                        <tr>
                            <th title="Model playing as black against a Random Player">Player&nbsp;&nbsp;</th>
                            <th title="How often the player scored a win (due to check mate or the opponent failing to make)">Wins&nbsp;&nbsp;</th>
                            <th title="Percentage of games without a winner (e.g. reaching maximum number of 200 moves OR stalemate). Displays LLMs proficiency in chess.">Draws&nbsp;&nbsp;</th>
                            <th title="Number of LLM erroneous replies per 1000 moves - how often did an LLM fail to follow the instructions and make a move, e.g. due haluscinations picking illegal move and not conforming to communication protocol. Shows model's instruction following capabilities and halusinations resistance">Mistakes&nbsp;&nbsp;</th>
                            <th title="Number of token's generated per one move. Demonstrates model's verbosity.">Tokens&nbsp;&nbsp;</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be populated here -->
                    </tbody>
                </table>

            </div>
            <p class="descriptions">
                <strong>METRICS:</strong><br/><br/>
                <strong>- Player:</strong> Model playing as black against a Random Player.<br/>
                <strong>- Wins:</strong> How often the player scored a win (due to checkmate or the opponent failing to make a move). Displays LLMs' proficiency in chess.<br/>
                <strong>- Draws:</strong> Percentage of games without a winner (e.g., reaching the maximum number of 200 moves or stalemate). Displays weaks' LLMs' proficiency in chess if it can't win.<br/>
                <strong>- Mistakes:</strong> Number of LLM erroneous replies per 1000 moves - how often did an LLM fail to follow the instructions 
                and make a move. E.g., due to hallucinations, picking illegal moves, not conforming to the communication protocol. Shows the model's instruction-following capabilities and hallucination resistance.<br/>
                <strong>- Tokens:</strong> Number of tokens generated per move. Demonstrates the model's verbosity.<br/><br/>
                <strong>NOTES:</strong><br/><br/>
                - LLMs played as black against a Random Player (as white).<br/>
                - 30+ game simulations for Random Player vs. LLM.<br/>
                - Bottom rows in green demonstrate how a Chess Engine (Stockfish v17) fares against a Random Player.<br/>
                - 1000 simulations for Random Player vs. Chess Engine and Random vs. Random.<br/>
                - <s>You see it right, LLMs scored 0 wins.</s> No longer the case, o1-mini being the 1st LLM scroging wins<br/>
                - <s>Using Draws instead of Wins to evaluate LLMs' chess proficiency</s>.<br/>
                - The default soritng is by Wins DESC, Draws DESC and Mistakes ASC <br/>
                - Strong models (those ones winning) are judged (in Chess proficiency) by % Won, weak ones - by % Draws <br/>
                - <strong>Mistakes</strong> metric gives an evaluation of LLMs' instruction-following capabilities and resistance to hallucinations (making up non-legal moves while having a list of legal moves provided in the prompt).<br/>
                - Sort by <strong>Mistakes</strong> column and get a ranking by instruction-following ability (models with the least mistakes being better) <br/>
            </p>
        </div>
        <div id="how-it-works" class="pane" style="display: none;">
            <p class="descriptions">
                <strong>Libraries and Dependencies Used:</strong><br/><br/>
                - <strong>chess:</strong> A Python library for handling chess game rules and basic operations, including board representation, legal move evaluation, and game state evaluation. This is not a chess engine runnig the actual caclulation of the best move.<br/>
                - <strong>Microsoft Autogen</strong> is used as a backbone for LLM communication. It also implements the interaction between a Chess Board and custom agents like GameAgent, RandomPlayerAgent, AutoReplyAgent, and others for simulating different player types.<br/>
                - <strong>Stockfish</strong> - the chess engine doing the actual best move calculation, used as a referrence to demonstrate what a real chess player's peformance is.<br/>
                <br/>
                <strong>Workflow:</strong><br/><br/>
                1. The game is initialized with a chess board and two players: a Random Player (as white) and an LLM (as black).<br/>
                2. The game loop runs until a termination condition is met, such as checkmate, stalemate, or reaching the maximum number of moves.<br/>
                3. Each player takes turns making a move. The Random Player selects a move randomly from the list of legal moves.<br/>
                4. The LLM is prompted to make a move using a structured dialog, which includes actions like getting the current board state, retrieving legal moves, and making a move.<br/>
                5. The game state is updated after each move, and the board is visualized if enabled.<br/>
                6. Game statistics are generated and stored at the end of the game.<br/>
                <br/>
                <strong>Dialog:</strong><br/><br/>
                Here is an example of a dialog that prompts a model to make a move:<br/>
                <pre class="snippet">
<span style="color:green">Proxy (to Player_Black):</span>
You are a professional chess player and you play as black. Now is your turn to make a move. Before making a move you can pick one of the following actions:
- 'get_current_board' to get the schema and current status of the board
- 'get_legal_moves' to get a UCI formatted list of available moves
- 'make_move <UCI formatted move>' when you are ready to complete your turn (e.g., 'make_move e2e4')
Respond with the action.

<span style="color:green">Player_Black (to Proxy):</span>
get_current_board

<span style="color:green">Proxy (to Player_Black):</span>
<span style="font-family: Chess;">♞ ♝ ♛ ♚ ♝ ♞ ♜ ♜
♟ ♟ ♟ ♟ ♟ ♟ ♟ ♟
· · · · · · · ·
· · · · · · · ·
· · · · · · · ·
· · · · · · · ·
♙ ♙ ♙ ♙ ♙ ♙ ♙ ♙
♖ ♘ ♗ ♕ ♔ ♗ ♘ ♖
</span>

<span style="color:green">Player_Black (to Proxy):</span>
get_legal_moves

<span style="color:green">Proxy (to Player_Black):</span>
a7a6, b7b6, c7c6, d7d6, e7e6, f7f6, g7g6, h7h6, a7a5, b7b5, c7c5, d7d5, e7e5, f7f5, g7g5, h7h5

<span style="color:green">Player_Black (to Proxy):</span>
make_move e7e5

<span style="color:green">Proxy (to Player_Black):</span>
Move made, switching player
                </pre>
            </p>
            <p class="descriptions">
                1 move - 1 dialog. The dialog is limmited to 10 turns (10 pairs of Proxy/Agent Request/Response messages). A maximum of 3 mistakes (not conforming to 
                communication notation, picking wrong action or wrong move) are allowed per dialog. 
                The game is terminanted and LLM is given a loss if the max turns OR of number of LLM mistakes is reached in the given dialog.
            </p>
        </div>
        <div id="considerations" class="pane" style="display: none;">
            <p class="descriptions">
            <span style="color:white;">
            -------------------<br/>
            January 22, 2025: R1 Challenges o1, thinking "surrogates"<br/>
            -------------------<br/><br/></span>
    
            Released on January 21, DeepSeek-R1 made a significant impact by showing similar
            or even better performance than OpenAI's o1 models across a range of math and
            coding benchmarks. All of this comes at a fraction of the cost when accessing
            their 671B model through their API. Besides, the model weights are open, and
            there are plenty of details about the training process—a stark contrast to
            OpenAI's secrecy regarding the o1/o3 family of models. And that's not all! For
            those interested in local models, there are smaller "distilled" reasoning models
            at 70B, 32B, 14B, etc., sizes.<br/><br/>

            So far, none of the so-called reasoning or thinking models have come close to o1
            (qwq-32b-preview, sky-t1-32b-preview, gemini-2.0-flash-thinking-exp-1219). They
            were a step back in instruction following and could hardly be steered when
            compared to non-thinking models. Let alone, they didn't perform as well in chess.
            I call them surrogates, verbosity generators mimicking but not replicating o1's
            behavior.<br/><br/>

            Deepseek-R1 (deepseek-reasoner-r1) was an extremely curious model to test, and
            now there are evaluation results in the Leaderboard.<br/><br/>

            Additionally, Google has just released an update to its Gemini 2.0 Thinking Model
            (gemini-2.0-flash-thinking-exp-01-21), which previously showed poor results. Two
            very interesting releases in two days...<br/><br/>

            <strong>NOTES:</strong><br/><br/>

            - There are now three models in a league of their own: o1-mini, o1-preview, and now
            deepseek-reasoner-r1. These are the only models with significant wins (>10%) and
            maintaining a positive material difference (~9) as opposed to a negative material
            difference for the resetGameInterval.<br/><br/>

            - Deepseek-reasoner-r1 is much more verbose (almost twice as many tokens as o1) and
            also makes more mistakes. Many games were lost due to the model making mistakes,
            unlike o1 models, which mostly fell out of the games due to losing or drawing
            (e.g., stalemate, insufficient material).<br/><br/>

            - Deepseek-reasoner-r1 showed distinctive behavior: sometimes it made moves without
            requesting the board state or legal moves list (i.e., issues make_move action in
            the very first response), sometimes it only requested the board state without
            getting the list of moves and decided on the move without a hint (in some cases
            picking the right move, in others wrong).<br/><br/>

            - Overall, o1 models are better all-round models (compared to R1), with better chess
            performance, as well as instruction following (Mistakes) and Durability (not
            falling out of the games, doing more moves on average).<br/><br/>

            - The rest of the "thinking" models (sky-t1-32b-preview@q4_0, qwq-32b-preview@q4_k_m,
            deepseek-r1-distill-qwen-32b@q4_k_m, deepseek-r1-distill-qwen-14b@q8_0,
            gemini-2.0-flash-thinking-exp-1219) can hardly follow prompt instructions, lasting
            on average 2~14 moves.<br/><br/>

            - Distilled dense 14B and 32B versions of Deepseek-R1 (deepseek-r1-distill-qwen-32b@q4_k_m,
            deepseek-r1-distill-qwen-14b@q8_0) did not impress—very poor instruction following,
            not even close to the full 671B MoE model. Could quantization have an effect?
            Don't know.<br/><br/>

            - Distilled R1 models use <code>&lt;think&gt;&lt;/think&gt;</code> tags to enclose
            "reasoning" tokens (those ones hidden for o1), sometimes they fail to put the
            opening <code>&lt;think&gt;</code> tag (most often in the very first reply).<br/><br/>

            - The new Gemini Thinking model (gemini-2.0-flash-thinking-exp-01-21) did improve a
            lot in instruction following. While the previous December version
            (gemini-2.0-flash-thinking-exp-1219) was almost useless, staying in the game on
            average for 2.3 moves (i.e., breaking instruction prompts in the 2nd move it was
            asked to make), the new model lasted on average 40 moves and showed far fewer
            mistakes.<br/><br/>

            In terms of chess, the newer gemini-2.0-flash-thinking-exp-01-21 showed a negative
            material difference and negligible draw count—way below other non-thinking models
            (even Google's own Gemma 2 9B).<br/><br/>

            - Gemini-2.0-flash-thinking-exp-01-21 also demonstrated much less verbosity in the
            outputs, providing to-the-point answers. Didn't investigate it deeply, yet it
            seems that now Gemini Thinking does proper isolation of reasoning tokens. Per
            <a href="https://ai.google.dev/gemini-api/docs/thinking">docs</a>, "On a standard
            request, the model responds with two parts, the thoughts and the model response.
            You can check programmatically if a part is a thought or not by seeing if the
            part.thought field is set to True." Autogen doesn't seem to register thought
            tokens in completion stats for Flash Thinking while it does so for R1.<br/><br/>

            - Earlier non-o1 thinking models did not do well with splitting the reasoning/thinking part
            from the final answer, R1 and newer Gemini Thinking do that (yet it didn't help
            the distilled R1 models).<br/><br/>

            <span style="color:white;">
            -------------------<br/>
            January 21, 2025: More Models, More Tests<br/>
            -------------------<br/><br/></span>
            - Added the new Claude 3.5 Sonnet (claude-v3-5-sonnet-v2) and also retested the previous version (claude-v3-5-sonnet-v1), giving them more runs
            (60 this time). What surprised me was not just the fact that v2 showed some wins, but that v1 demonstrated even more wins 
            (although losing to the random player more often). 
            Back in November, when I did 30 runs of Sonnet 3.5, there were 0 wins. 
            Did Anthropic change something in v1 as well, or was it just a question of stochasticity?
            <br/><br/>
            - Conducted more runs of GPT-4o models (gpt-4o-2024-05-13, gpt-4o-2024-08-06, gpt-4o-2024-11-20). The August version also achieved a win, yet
            it also had its first non-zero mistake (previous 30-run result had a perfect 0 mistakes) - this time, that happened due to Azure's content
            filter halting one of the games.
            <br/><br/>
            - OpenAI's and Anthropic's models are still the most durable models, i.e.,
            demonstrating the least number of mistakes, staying in almost all games
            until the very end without falling off due to a random glitch/hallucination
            or breaking the prompt instructions. Clearly, it is a challenge for most models
            to sustain a 100-turn (200-move game) with an average of 3-4 dialog interactions per game turn. 
            <br/><br/>
            - Deepseeks R1 distilled into 32B Qwen (deepseek-r1-distill-qwen-32b@q4_k_m) didn't perform well
            - barely able to move past a couple of turns in the chess game, no better than QwQ or Flash Thinking.
            <br/><br/>
            - o1 models are still special being the only models maintaing positive material diff (gaining more piaces rather than losing them)
            versus most other models having a significant negative diff suggesting the wins for non-o1 models can hardly be attributed
            to models reasoning performance (i.e. with the models meaningfully moving the pieces rather than faking a game).
            <br/><br/>
            <span style="color:white;">
            -------------------<br/>
            January 16, 2025: First wins by non-reasoning model<br/>
            -------------------<br/><br/></span>
            The November 2024 update to GPT-4o demonstrated a few wins, something non-o1 models couldn't do before. Yet, what is curious is that the updated
            model not only scored wins but also lost to the Random Player more often than others.
            <br/><br/>
            <span style="color:white;">
            -------------------<br/>
            January 14, 2025 : Reasoning Models, First Wins<br/>
            -------------------<br/><br/></span>
            In my initial notes (see below), I expressed skepticism about LLMs ever being capable of achieving meaningful wins against a Random Player 
            (let alone a dedicated chess engine). I also mentioned the ARC Challenge as a similar benchmark that is difficult or unsolvable by LLMs.
            Yet, in late December 2024, OpenAI introduced their o3 model, which excelled in 
            <a href="https://arcprize.org/blog/oai-o3-pub-breakthrough">ARC-AGI-1</a>.<br/><br/>
            Around the same time, I received API access to o1-mini, and it was impressive! o1-mini scored 9 wins in 30 games (30%), 
            making it the first model
            capable of meaningful chess games. Next, I tried o1-preview, achieving an even more impressive 46.7% win rate.<br/><br/>
            The o1 models did something different; they played a meaningful game rather than randomly moving pieces on the board as 
            seen with older "non-reasoning" models. They formed a league of their own—a "strong" model capable of winning.<br/><br/>
            I also tested a number of other reasoning models introduced after o1—Google's Gemini 2.0 Flash Thinking (via API), 
            QwQ 32B (4-bit quantized via LM Studio), and Sky T1 32B (also 4-bit quantized via LM Studio).
            The results were underwhelming, to say the least—those 3 models couldn't complete even a single game, often failing 
            after a few moves (due to breaking the communication protocol or making illegal moves).
            Just like the o1 models, they produced lots of tokens, yet unlike o1, 
            which seems to have 2 separate stages—thinking (those hidden tokens) and producing the 
            final answer—the other "thinking" models just stream lots of tokens without caring about 
            following any instructions as to what they are asked to produce.
            Verbosity and failing to adhere to instructions seem to plague not just the o1 competitors 
            but also newer models (e.g., check Deepseek v3).<br/><br/>
            <strong>NOTES:</strong><br/><br/>
            - When LLMs achieve a 90% win rate against a Random Player, I will replace it with Stockfish.<br/>
            - You can find conversation logs for 
            o1-mini <a href="https://github.com/maxim-saplin/llm_chess/blob/main/_logs/no_reflection/_21.12.2024_o1-mini-2024-09-12/output.txt">here</a> 
            and for o1-preview <a href="https://github.com/maxim-saplin/llm_chess/blob/main/_logs/no_reflection/_03.01.2025_o1-preview-2024-09-12_2/output.txt">
            here</a><br/><br/>
            - Conversation logs for <a href="https://github.com/maxim-saplin/llm_chess/blob/main/_logs/no_reflection/_09.01.2025_gemini-2.0-flash-thinking-exp-1219/output.txt">Gemini 2.0 Thinking</a>,
            <a href="https://github.com/maxim-saplin/llm_chess/blob/main/_logs/no_reflection/_14.01.2025_sky-t1-32b-preview_q4-0/output.txt">QwQ</a>
            and <a href="https://github.com/maxim-saplin/llm_chess/blob/main/_logs/no_reflection/_14.01.2025_sky-t1-32b-preview_q4-0/output.txt">Sky T1</a><br/><br/>
            - While o1 models used a lot of tokens (1221 tokens per move for o1-mini and 2660 
            for o1-preview vs. below 100 tokens for an average model), their replies were concise (most of the tokens 
            were hidden ones) and had few mistakes.<br/><br/>
            - OpenAI models might have an advantage over other models because the prompts have been crafted with GPT-4 models.
            This might explain why many models perform worse. Contrary to this point, there are non-OpenAI models (e.g., Anthropic)
            that do not struggle with instruction following. I believe the factor of prompts and adjusting prompts for each specific model plays a minor role.<br/><br/>
            - An idea: while other (non-o1) reasoning models might be poor instruction followers, why 
            not introduce a deliberate step of final answer synthesizing? I.e., use a cheaper LLM (e.g., 4o-mini) 
            to get the long scroll from a reasoning model and prompt it to produce a final answer. 
            Will the reasoning models show better chess abilities?
            <br/><br/>
            <span style="color:white;">
            -------------------<br/>
            November 12, 2024 : Initial Observations, Opinion<br/>
            -------------------<br/><br/></span>
            Language Models can make moves in a chess game, but they cannot actually play chess or progress towards a victory. 
            The experiment started after taking a class at DeepLearning, which taught the Microsoft Autogen framework. One of the classes demonstrated
            a simulation of a chess game between LLMs. I was immediately intrigued by the idea of putting different LLMs head-to-head in a chess game competition. 
            However, I was surprised that the naive prompting strategy from the class never led to a game completion. Extending prompts didn't help. 
            I ended up testing LLMs' performance in a chess game using a Random Player. A human player with reasonable chess skills would have no problems winning 
            against a random player, yet LLMs failed miserably in this competition.
            <br/><br/>
            I suspect that crushing this "LLM Chess" eval might be as hard as the <a href="https://arcprize.org">ARC Challenge</a>—a benchmark created to demonstrate 
            the true nature of text-generating LLMs, exploit their weaknesses, and show how LLMs struggle with reasoning. "It's easy for humans, but hard for AI."
            <br/><br/>
            LLMs and Transformer-based models can be trained specifically to play chess. There are projects on the internet where people have fine-tuned LLMs
            as chess players. Yet, those are specialized models that can't be good chat models.
            <br/><br/>
            I am looking forward to testing new releases of SOTA and frontier models. It would be great to see a model that starts scoring wins against
            the chaos monkey while maintaining performance at traditional chat tasks.
            <br/>
            <br/>
            <strong>NOTES:</strong><br/><br/>
            - More data on game simulations is available <a href="https://github.com/maxim-saplin/llm_chess/blob/main/docs/_data/refined.csv">here</a> and 
            <a href="https://github.com/maxim-saplin/llm_chess/blob/main/docs/_data/aggregate_models.numbers">here</a>.<br/><br/>
            - No history of moves is available to LLM, no reflection used (giving the model "time to think").<br/><br/>
            &nbsp;- Experiments with reflection suggest that LLMs do even worse when they are prompted to evaluate options before making a move
            (<a href="https://github.com/maxim-saplin/llm_chess/blob/main/_logs/_not_OK_logs/reflection/aggregate_results.csv">reflection results</a>).
            &nbsp;- Could LLMs improve their performance if given the whole log of the game?<br/><br/>
            - The chess engine ( <a href="https://stockfishchess.org">Stockfish</a>) has a 100% win rate with an average game taking 32 moves to complete.<br/><br/>
            &nbsp;- Stockfish 17, macOS, 0.1ms time limit (vs 0.1s default) - with decreased performance, Stockfish dominates over Random Player.<br/><br/>
            - Random Player (as white) wins over Random Player (as black) in 10.5% of cases - LLMs scored 0 wins.<br/><br/>
            &nbsp;- Indeed, giving the right of the first move gives an advantage to the white player.<br/><br/>
            &nbsp;- LLMs do worse than random players.<br/><br/>
            &nbsp;- It's as if an LLM had no goal to win, as if it was its intention to keep the game going. What if I prompted it and told it that 200 moves is the maximum and the game ends after? Would it try harder? Can adding to a system prompt an explicitly instruction to Win help?<br/><br/>
            - While some models are less verbose and follow the rules strictly (e.g., OpenAI), others are verbose.<br/><br/>
            &nbsp;- Initially, I used exact match when communicating with an LLM and prompted it to reply with action names (show board, get legal moves, make move) - worked well with OpenAI.<br/><br/>
            &nbsp;- After the list of models was extended, the original prompts had issues steering them.<br/><br/>
            &nbsp;- As a result, I changed the communication protocol to use regex and be tolerant to reply format, doing its best to extract action and arguments from LLM replies.<br/><br/>
            - Since models don't score any Wins there must be some alternative metric demosntrating game progress.<br/><br/>
            &nbsp;- For the time being using Draws, the more draws - the better.<br/><br/>
            &nbsp;- Yet most of the draws scored are due to hitting the 200 max moves limmit and hence the metric demonstrates the adherence to communication protocol/prompt cpnverntions.<br/><br/>
            &nbsp;- Logs also contain "Material Count" metrics - the weighted scores of piaces a player has, at the beginning a player has a total of 39 units of material.<br/><br/>
            &nbsp;- Material difference could be a good metric to evluate progress, the player having more material left as the game progress is at a better position.<br/><br/>
            &nbsp;- Yet most of the models demonstrated negative material difference and one of the models (gpt-35-turbo-0125) failed to make a single move having a material difference at 0 putting it above models that had negative material while staying in the game much longer.<br/><br/>
            &nbsp;- It might be resonable to create a computed metric that account for both the material and length of the game, addressing the endless pointless game concern, as well as never changing material diff due to failing to early.<br/><br/>
            - What if the model is not given the list of legal moves? Will the model figuring out legal moves on their own and struggle to progress? Can giving the models a list of legal moves essentially break reasoning turning the game into simple instruction following (i.e. pick one item from the list rather than win in the game)?<br/><br/>
            - The older GPT-4 Turbo did better than newer GPT-4o version, this is a yet another eval demonstrating how newer models performed worse supporting the claim the the 4o family of models are smaller and cheaper to run models.<br/><br/>
        </div>
        <a class="gh" href="https://github.com/maxim-saplin/llm_chess/" target="_blank">
            <img src="icons/gh.png" alt="GitHub Icon">
            Project's GitHub
        </a>
    </div>
    <div id="popup" style="display: none;">
        <p id="total-games"></p>
        <p id="wins"></p>
        <p id="losses"></p>
        <p id="draws"></p> 
        <p id="average-moves"></p>
        <p id="material-diff"></p>
    </div>
</body>
</html>
